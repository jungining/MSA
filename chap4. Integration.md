# 4. Integration(통합)

통합에 대한 잘못된 이해로 잘못 통합하면 재앙이 기다릴 것이다. 

## 4.1 이상적인 통합 기술 모색

이상적인 통합을 위해서는 
- 변경으로 인해 기존 Service client가 영향을 받는 일이 있어서는 안 되며,
- 마이크로서비스 간의 통신에 사용되는 API가 기술 중립성(특정 기술에 종속되지 않도록 함)을 유지해야 하고,
- 내부 구현의 세부 표현을 외부로 노출하도록 하는 기술을 피해야 한다. (Service client의 변경 비용 증가를 막기 위해)

## 4.3 공유 데이터베이스 (DB)

가장 일반적인 통합 형태, 관련된 데이터베이스를 하나의 데이터베이스로 통합하는 패턴은 다음과 같은 단점이 있다.
1. 외부에서 내부의 구현 상세를 조회하고 결합하는것을 허용하게 된다. (공격받을 만한 만만한 대상이 됨)
2. client들이 특정 기술을 선택하는 범위가 제한되어 느슨한 결합을 가질 수 없게 된다.
3. 로직이 여러군데에 분포되어, 여러 곳에서 버그를 수정/배포해야한다.

DB통합은 최대한 피하라.


## 4.4 동기 / 비동기

- 동기(sync) 통신 : 원격 서버에 대한 호출이 완료될때까지 연산 작업이 중단된다.
- 비동기(async) 통신 : 호출자는 작업이 완료되었다는 회신을 기다리지 않는다.

두 가지 방식은 request/response 또는 이벤트 기반이라는 관용적인 두 가지 협력 방식을 가능하게 한다.
- request/response 협력 방식 : 클라이언트가 요청을 시작하고 기다림
- 이벤트 기반 협업 : 클라이언트는 요청하는 대신 일(사건)이 발생되었음을 알리고, 다른 당사자들이 무엇을 해야 할지 알기 기대한다. 본질상 비동기적

두 방식의 장단을 잘 고려하여 선택하자.

## 4.5 오케스트레이션(Orchestration)과 코레오그라피(choreography)

### 오케스트레이션(Orchestration)
- 오케스트라 지휘자처럼 프로세스를 안내하고 구동하는 하나의 중앙 두뇌에 의존
- 단점 : 중앙 서비스에 지나치게 관리 권한이 부여됨, 높은 변경 비용

### 코레오그라피(choreography)
- 발레 무용수들이 자신의 역할을 알고 주변 무용수에 반응하는것처럼 시스템 각 부분에 작업 내용을 알리고 세부사항을 수행
- 장점 : 이벤트를 발산할 뿐, 다른 서비스가 이벤트를 구독하기만 하면 됨
- 느슨한 결합, 유연, 변경 쉽게 수용

지금부터 요청/응답을 고려할 때 적합한 두가지 기술 PRC/REST에 대해 살펴보자

## 4.6 원격 프로시저 호출(remote procedure call, RPC)
- 지역 호출을 통해 원격 서비스를 실행하는 기술
- RPC 구현체들(SOAP, 쓰리프트(Thrift), 프로토콜 버퍼(protocal Buffer))은 매우 빠르게 시작할 수 있는 클라이언트와 서버 스텁을 생성하게 함.
- 장점 : 쉬운 사용성, 일반적인 메서드 호출처럼 사용하고, 이론적으로 다른 것은 신경스지 않아도 된다는 점

단점들도 있다.

- 기술 결합 : 자바 RMI 와 같은 일부 RPC 메커니즘은 특정 기술과 지나치게 엮여 있어 클라이언트와 서버에 사용될 기술을 제한한다. 
- 지역호출은 원격호출과 다르다 : RPC 아이디어의 핵심은 원격 호출의 복잡성을 은폐하는 것이다. 하지만 RPC는 수많은 구현체가 이를 지나치게 은폐한다.
- 취성(쉽게깨지거나 부서지는 성질): 가장 대중적인 RPC 구현체들도 깨지기 쉬운데, 자바 RMI 가 좋은 예다.

그럼 RPC 는 형편없는가? 단정 짓기는 이르다. 데이터베이스 통합과 비교해보면 RPC는 요청/응답의 협업 방식 측변에서 확실히 개선되었다. 하지만 또 다른 대안도 고민해야 한다.

## 4.7 REST

REST는 웹에서 영감을 받은 아키텍처 양식. 

###  REST 와 HTTP
HTTP가 제공하는 몇몇 기능(GET, PUT, POST등)은 HTTP상의 REST를 쉽게 구현할 수 있게 한다. 프록시, Load balancer, 보안 절차를 더 쉽게 만들기 위한 수많은 도구 등 지원 도구와 기술의 거대한 생태계도 제공한다. HTTP는 RPC구현에 쓰일 수 있기도 하다.

### 애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS:hypermedia as the engine of applicaton state)
클라이언트와 서버가 결합하지 않게 도와주는 또 다른 원칙.

- 하이퍼미디어란 : 하나의 콘텐트가 TEXT나 이미지, 사운드와 같은 다양한 포맷의 다양한 콘텐트를 링크하는 개념

이 하이퍼미디어 컨트롤을 통해 SERVICE CLIENT들을 위한 장점을 얻어낼 수 있다. client는 앨범을 구매할 때 uri 하부 세부 사항을 추상화하여 CLIENT와 SERVER의 결합을 피할 수 있다. 

### 지나친 편의를 주의하라.

Restful 웹 서비스생성을 도와주는 프레임워크가 인기를 얻고 있는데, 단기적으로는 득이 되지만 장기적으로는 고통을 준다는 점에서 일장일단이 있다. 예를 들어, 일부 프레임워크는 데이터베이스 표현을 그대로 전달받아 프로세스 내의 객체로 deserialize(역직렬화) 하고, 외부로 직접 노출하는 작업을 쉽게 만들어버린다.

### HTTP기반 REST의 단점

- 클라이언트와 서버간의 공유 코드는 매우 위험할 수 있다. 
- 일부 웹 서버 프레임워크가 실제로는 모든 HTTP 메서드를 제대로 지원하지 않는다.
- HTTP 요청에서 늘 발생하는 부하 역시 문제


## 4.8 비동기 이벤트 기반의 협업 구현
이벤트 기반의 비동기 통신을 살펴보자.
### 기술선택

기술선택시에는,

1. 마이크로서비스가 이벤트를 발산하는 방법
2. client가 생성된 이벤트를 찾는 방법

을 고려해야 한다.

두 가지 문제를 모두 처리하는 메시지 브로커에는 Rabbit MQ가 있다. ATOM이라는 REST 호환사양서는 이벤트의 구독과 게시를 처리할 수 있게 한다.

### 비동기 아키텍처의 복잡성
비동기 아키텍처는 복잡하다. 메시지의 게시 / 구독관리에 필요한 요소 / 우리가 직면할 수 있는 모든문제들이 복잡성에 해당한다. 그러니 적용하는데에 신중하자.


## 4.10 Rx(반응형 확장) : reactive extension

- 다수의 호출 결과를 조합하고 그 결과에 따라 연산을 실행하는 메커니즘이다.
- 데이터를 요청하는 대신 데이터에 대한 연산을 수행하고, 그 연산 결과를 관찰하며, 변경에 따라 반응한다.
- 하위 서비스에 대해 동시에 발생하는 호출들을 쉽게 처리하면서 다수의 호출을 함께 조합할 수 있다.

## 4.11 마이크로서비스 세계에서 코드 재사용의 위험과 DRY

> DON'T REPEAT YOURSELF

: 중복된 코드뿐만이 아니라 행동양식과 지식의 중복을 다 회피하라!


## 4.12 참조에 의한 접근

자원에 대한 정보를 전달할때는 자원의 새로운 상태를 확보할 수 있도록 원본 자원의 참조도 포함하라. EX) 주문 안내 메일에 URI만 포함하여 보내기

단점 : 서비스의 부하가 커질 수 있다.


## 4.13 버전관리
사람들은 서비스의 인터페이스를 결국에는 변경하게 될 것이라는 당연한 우려를 하면서 버전관리 방법을 이해하고 싶어한다. 이 문제를 더 세분화하고 처리할 수 있는 다양한 단계를 살펴보자.

- 호환성을 깨뜨리는 변경은 가능하면 늦추자. 그 방법으로는 서비스와 처음부터 너무 강하게 결합되지 않도록 하는것이다. 서비스를 가능한 한 유연하게 소비하는 클라이언트를 만들려는 사례는 '전송할 때는 보수적으로, 받아들일 때는 자유롭게' 라는 포스텔의 법칙을 입증한다. 
- 소비자를 일찍 고장내는 변경은 최대한 빨리 발견하는것이 중요하다.
- Semantic versioning : MAJOR.MINOR.PATCH

> - MAJOR 버전 번호의 증가 : 하위 호환성이 깨진 변경이 발생했음
> - MINOR 버전 번호의 증가 : 하우 호환성을 유지하면서 새로운 기능들이 추가되었음
> - PATCH 버전 번호의 증가 : 기존 기능의 버그를 수정했음

- 다른 엔드포인트와 공존 : 호환성을 깨뜨리는 변경을 릴리즈하고 싶다면 구버전의 엔드포인트와 신버전의 엔드포인트를 모두 노출하는 새로운 서비스 버전을 배포해야한다.
- 구 소비자의 트래픽을 구버전에, 신규 소비자를 신버전에 라우팅 : 한 서비스의 내부 버그를 고치려면 두 벌의 다른 서비스를 수정하고 배포해야 한다는 단점이 있다.


## 4.14 사용자 인터페이스
 데스크톱 웹 어플리케이션에는 방문자가 사용하는 브라우저의 종류와 해상도 등의 제약이 있고, 특히 모바일에는 완전히 새로운 제약들이 존재한다. 상호작용의 성질 역시 달라진다. 태블릿 에서는 PC 처럼 쉽게 오른쪽 버튼클릭을 할 수 없다. 모바일폰에서는 대부분의 동작을 엄지 손가락으로 수행하며 한손으로 사용가능한 인터페이스를 원할 것이다.

따라서 우리의 주요 제품인 헥심 서비스들이 동일하더라도 각 인터페이스의 다양한 제약에 따라 그 서비스들을 적절히 적용할 방법이 필요하다.

### UI 부분 구성

UI가 API 를 호출하고 UI 컨트롤과 매핑하는 대신 서비스들이 UI 생성에 필요한 일부 UI 를 직접 제공할 수 있다.

### 프론트엔드를 위한 백엔드(BFF)
백엔드 서비스와의 호출이 많은 인터페이스 문제나 각종 디바이스별 콘텐트의 맞춤화 요구에 대한 일반적이 해결책은 서버 측의 집합 엔드포인트 또는 API 게이트웨이를 제공하는 것이다. 

발생할 수 있는 문제는 모든 서비스에 대한 거대한 단일 계층이 될 수 있다는 것이다. 이는 모든것을 한장소에 밀어 넣고 다양한 사용자 인터페이스의 분리를 어렵게 만들며, 독립적으로 릴리스 할수 있는 능력을 제한한다.

프론트엔드를 위한 백엔드 라고 하는 패턴에서는 특정 UI에 집중하는 팀이 해당 서버측 컴포넌트도 담당한다. 이 방법의 위험성은 집합계층의 위험성(포함해서는 안되는 로직을 포함할 수 있다)과 유사하다. 따라서 백엔드가 사용하는 다양한 기능의 비지니스 로직은 서비스에 존재해야 하고 BFF 는 특정 사용자 경험을 제공하기 위한 행동 양식만 포함해야 한다.


## 정리

- 데이터베이스 통합은 최대한 피하라.
- REST 와 RPC의 장단점을 이해하고 요청/응답을 통합하는 좋은 출발점으로 REST를 고려하라.
- 오케스트레이션보다는 코레오그래피를 우선하라.
- 포스텔의 법칙을 이해하고 관대한 독자 패턴을 사용해서 호환성을 깨뜨리는 변경과 불필요한 버전을 피하라
- 그성 계층으로서의 사용자 인터페이스를 생각하라.
