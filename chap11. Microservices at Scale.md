# 11. 대규모 마이크로서비스

분리된 많은 서비스의 장애를 처리하거나 수백개의 서비스를 관리해야 한다면, 대응 패턴은 무엇일까?

## 11.1 장애는 어디에서나 발생한다
- 어떤 것이든 고장날 수 있다는 가정을 명심하고 장애에 대한 계획을 세운다면 다양한 절충안을 준비할 수 있다.

## 11.2 얼마나 많아야 너무 많은건가?
- 오토스케일링 기능이 없다면, 교차 기능 요구사항의 이해가 필요하다.
- 교차기능 요구사항 : 응답시간/지연시간, 가용성, 데이터의 내구성
- 교차기능 요구사항은 서비스마다 다르므로, 요구사항을 지속적이며 체계적으로 측정할 방법이 필요하다.

## 11.3 기능 분해
- 회복력 있는 시스템 구축에서 가장 중요한 것은 `안전하게 기능을 분해할 수 있는 능력`이다.
- 모놀리식 애플리케이션에서는 시스템 상태가 ON/OFF 밖에 없지만, 마이크로서비스 아키텍처에서는 훨씬 미묘한 상황을 고려 한다.

이제 장애가 발생할 때 처리할 수 있도록 기술적인 관점에서 가능한 일들을 고려해보자.

## 11.4,5 아키텍처 안전 조치
> 아키텍처 안전 조치 : 무언가 잘못될 때 벌어지는 심각한 파급 효과를 막기 위해 이용하는 몇가지 패턴

1. 타임아웃 - 항상 기본 타임아웃 시간을 적절히 설정하라.
2. 회로 차단기 - 임계치를 설정하고, 임계치를 초과했을때 커넥션을 중단한다. 복구 여부를 확인해 정상 임계치 도달시 커넥션을 리셋한다.
3. 격벽(bulk head) - 특정 하위 서비스가 느려지게 되더라도 그 서비스의 커넥션 풀에서만 영향을 받고 다른 호출은 정상 처리됨을 보장한다.
4. 격리 : 서비스간의 격리도를 높이면, 상위 서비스는 하위 서비스로 인해 계획되지 않은 장애로부터 영향을 받을 가능성이 낮아진다. 서비스 소유자 간에 조율할 것도 줄어든다.

## 11.6 멱등성(idempotent)
- 멱등성 : 역효과 없이 호출을 반복할 수 있음
- 이벤트를 멱등 방식으로 처리함으로써 안전성을 보장한다.

## 11.7 확장

확장을 하는 이유
1. 장애에 더 잘 대응하기 위해
2. 성능(더 큰 부하, 적은 지연시간)을 위해 확장한다.

대표적인 확장 기술
1. 더 크게 만들기 - 많은 자원 투입(수직 확장) : 고비용, 탄력성 낮다. 빠른 해결방안이 될 수 있음
2. 작업부하 나누기 - 기능을 별개의 서비스로 분리
3. 위험 분산 - 계란을 한 바구니에 담지 않기
4. 부하 분산 - 고용량 고비용의 하드웨어 장비에서부터 모드 프록시와 같은 방법이 있음
5. 작업자 기반 시스템
6. 다시 시작하기 - 재설계

## 11.8 데이터베이스 확장
- 서비스의 가용성과 데이터의 내구성 개념을 분리하는것이 중요하다.
    - 데이터베이스가 다운될 경우, 데이터 유실은 없지만 데이터베이스 자체는 가용되지 않음.
    - 대기(Standy) 모델 : 대기 복제(replica) 데이터베이스 이용
- 읽기용 확장(scaling for read) : 간편
    - 읽기 복제(replica)사용 모델이 있음. 
    - 예전에는 읽기 복제가 유행이었지만, 작업량 적고 향상된 성능을 보이는 캐싱을 추천.
- 쓰기용 확장(scaling for wirte)
    - 샤딩(sharding)을 사용하는 모델이 있음
- 공유 데이터베이스 스트럭처
    - 동작 중인 데이터베이스가 독립적인 다수의 스키마(한 스키마당 다수의 마이크로서비스)를 호스팅
    - 대재앙 초래 가능
- 명령과 질의에 대한 책임 분리 패턴, CQRS(Command and Query Responsibility Segregation)
    - 시스템의 일부가 명령을 처리해서 상태를 변경하는 요청을 캡쳐하며 시스템의 다른 부분이 쿼리를 처리한다.
    
## 11.9 캐싱
캐싱은 다른 서비스까지의 불필요한 왕복을 제거한다. 
- 클라이언트, 프록시, 서버 측 캐싱 세 가지를 혼용해서 사용하되, 감당해야 할 부하와 시스템의 역량을 알고 해야 한다.
- HTTP의 캐싱 : cache-control, Expires, ETag 제공
- write-behind 캐싱(쓰기용 캐싱) : 로컬 캐시에 먼저 쓰고 데이터는 나중에 하위소스에 플러쉬, 대량 쓰기에 유리
- 너무 많은 곳에 캐싱하게 되면 클라이언트가 가진 데이터의 최신상태를 유지하는것이 힘들어진다. 
- 캐시 남발/중독 주의하자.


## 11.10 자동 확장 (Auto Scaling)
- 반응적이고 예측적인 자동 확장은 비용 효율을 훨씬 높일 수 있으며, 안정적이다.
- 부하에 따라 확장한다면, 너무 빨리 축소되지 않도록 해라.

## 11.11 CAP 정리
![image](https://www.researchgate.net/profile/Hamzeh-Khazaei/publication/282679529/figure/fig2/AS:614316814372880@1523475950595/Visualization-of-CAP-theorem.png)
> 우리는 실패 모드에서 두 가지 모드를 취하게 된다.

- CAP theorem (CAP 정리)
    - Consistency(일관성) : 다수의 노드로부터 동일한 대답을 얻어야 한다.
    - Availability(가용성) : 모든 요청이 응답을 받는다.
    - Partition tolerance(분할용인) : 시스템 부분간의 통신이 가끔식 실패한다는 사실을 다루는 시스템의 능력
- 세 가지 요소의 균형을 갖는게 중요하다.
- 무엇을 희생하느냐, AP 또는 CP 중 어떤 것이 옳은 건지는 상황에 따라 다르며, 양자택일이 아니다.

## 11.12 서비스 발견(Service discovery)
- 주어진 환경에서 실행되고 있는 것을 파악해서 모티너링해야 한다.
- DNS : DNS는 이름을 하나 이상의 머신 IP 주소와 연결하게 해준다. 이를 부하 분산기에 그 포인트를 연결할 수 있다.
    - 도메인 템플릿 사용가능

## 11.13 동적 서비스 레지스트리
- zookeeper, [consul](https://www.consul.io/), [Eureka](https://sabarada.tistory.com/61)

## 11.14 문서화 서비스
 - Swagger, [HAL(Hypertext Application Language)](https://velog.io/@pop8682/%EB%B2%88%EC%97%AD-HAL-Hypertext-Application-Language)과 HAL 브라우저

## 11.15 자기 기술 시스템
- 인간형 레지스트리(humane registry) : 사람이 조직의 서비스에 관한 정보를 위키처럼 쉬운 방식으로 기록할 수 있는 장소를 두는 것
