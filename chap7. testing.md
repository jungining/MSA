# 7. 테스팅

목표 : 세분화된 시스템의 테스팅과 관련된 문제를 해결하고, 새로운 기능을 릴리즈할 수 있는 해결책을 제시한다.

> SW를 가능한 한 빨리 실환경에 적응하려는 세력 VS SW의 충분한 품질을 보장하려는 세력 

둘 사이의 균형을 유지하기 위해 테스트의 종류를 이해하는것이 중요하다.

## 7.1 테스트의 종류
 
- 단위 테스팅 : 좁은 범위의 단위 테스트
- 속성(성능) 테스팅 : nGrinder와 같은 성능 테스트
- 인수 테스팅 : 넓은 범위의 End to End 테스트
- 탐색 테스팅 : 고객에 의한 최종 제품 평가 테스팅

> 필자는 가능한 많은 자동화를 추구해 수동 테스트를 탈피하길 추천.


## 7.2 테스트의 범위

마이크 콘의 테스트 피라미드는 자동화 테스트를 Unit / Service / UI로 분리
- Unit(단위) 테스트 : 단일 함수 또는 메서드 호출을 테스트하는것. 비즈니스 중심 테스트, 기능의 정상 동작 유무에 대한 빠른 피드백
- Service 테스트 : 사용자 인터페이스를 우회해서 서비스들을 직접 테스트.
- End to End 테스트(UI) : 시스템 전체에 대해 수행하는 테스트.
- 피라미드 위로 올라갈수록 테스트한 기능이 제대로 동작한다는 확신이 커지며 테스트 범위도 늘어난다. 
- 안티패턴/테스트 아이스림콘/역피라미드 : 작은 범위의 테스트가 거의 없고 대부분 큰 범위의 테스트로 이루어져 있음

절충안 : 다른 범위의 테스트가 필요하다.

## 7.3 서비스 테스트 구현하기
 
 - 서비스 테스트는 테스트하려는 서비스와 다른 서비스를 격리하기 위해 다른 협업자 모두를 스텁화하는 몇 가지 방법이 필요하다.
 - 하위 서비스를 스텁으로 만들어 사용

### 테스트 스텁( Test stub )이란?

테스트 중인 모듈이 호출하는 다른 소프트웨어 구성 요소(예: 모듈, 변수, 객체)를 일시적으로 대체하는 소프트웨어 구성 요소 [출처](https://blog.naver.com/suresofttech/221180956096)

- 여러번의 호출을 상관하지 않음
- 서비스 테스트를 위해 목보다 스텁 사용


### Mock이란?

실제 객체를 만들어 사용하기에 시간, 비용 등의 Cost가 높거나 혹은 객체 서로간의 의존성이 강해 구현하기 힘들 경우 가짜 객체를 만들어 사용하는 방법 [출처](https://www.crocus.co.kr/1555)

- 예상된 부작용이 발생하는지 확인하는데 유용
- 호출의 수행까지 보장



## 7.4 ~ 7.7 까다로운 End-to-End /  단점
- 서비스 당 End-to-End를 추가하게 되면, 다른 서비스의 버전에 대한 문제가 생긴다.
- 다른 서비스가 수행하는 End-to-End Test와 중복될 수 있다.
- 아래와 같이 여러 서비스의 파이프라인을 단일 End-to-End Test로 수렴하여 처리할 수 있다.


### 단점 : 신뢰할 수 없고 취약한 테스트

1. 어떤 팀에서 이 테스트를 만들어야 할까?
- 테스트에 대한 실질적인 소유권이 없으면 테스트의 결과물이 무시되곤 한다.  
2. 얼마나 오래 걸릴까?
- 시간이 오래걸린다...
3. 엄청난 적체
- 긴 피드백 주기
4. 메타버전
- 여러 서비스를 함께 배포한다면, 서비스들끼리 자주 결합되어버리는 상황에 빠진다.

소수의 테스트에 집중함으로써 통합 테스트의 단점을 줄일 수는 있지만, 모두 없애지는 못한다. 더 나은 방법은 바로!

## 7.8 우리를 구할 소비자 주도 테스트

소비자 주도 계약(consumer driven contracts)은 서비스에 대한 소비자의 기대 사항을 정의한다. 소비자의 기대 사항을 테스트할 수 있도록 코드로 표현한다. 해당 테스트는 생산자가 수행한다. 소비자 주도 계약이 완벽하게 수행되도록 생산자의 지속적 통합 서버 빌드의 일부분으로 수행되야 한다.

출처: [김용환 블로그 - 소비자 주도 계약 테스트](https://knight76.tistory.com/entry/소비자-주도-계약-테스트)


### [팩트](https://docs.pact.io/)
- 소비자 주도 테스팅 도구. 
- 팩트 파일: json 형식의 명세서.
- 동작 방식 (순서)
    - 소비자는 생산자에 대한 기대 사항을 정의
    - 로컬 목 서버 실행
    - 팩트 명세 파일을 생성하기 위해 그 서버에서 기대사항 실행 
    - 생산자는 팩트 명세서를 이용하여 소비자 명세서가 생산자의 api를 호출하고 응답하는지 검증.

## 7.9 End-to-End 테스트를 사용해야 하는가?
- 유의적 모니터링이라는 기술을 사용하는데 여전히 사용하고 있다.
- 감소된 위험과 순환 시간 간의 균형을 유지할 유용한 안전망을 형성할 수있다.
- 실환경에 배포하기 전에 결함을 제거하기 위해 모든 결함을 제거했음을 확신할 수 없다는 것과, 실환경에서 적절한 처리와 모니터링이 여전히 필요하다는것을 이해하는 한 End-To-End 테스트는 합리적인 결정이 될 수 있다. 


## 7.10 출시 후 테스팅
대부분의 테스팅은 시스템이 실환경에 배포되기 이전에 완료되나, 배포 전의 테스팅을 통해서는 장애의 가능성을 완전히 없앨 수는 없다.

1. 배포를 릴리즈와 분리하기
- 스모크테스트 : 본격적인 테스트의 수행에 앞서, 시스템, 컴포넌트, 소프트웨어 프로그램 등 테스트 대상이나 제품의 빌드(제품 설치 패키지)가 구축된 테스트 환경에서 테스트가 가능한지를 판단하기 위해 주요 모듈이나 시스템을 간단하게 테스트 [스모크 테스트란 무엇인가?](https://sambalim.tistory.com/139)

- Blue/Green 배포 : 애플리케이션 또는 마이크로서비스의 이전 버전에 있던 사용자 트래픽을 이전 버전과 거의 동일한 새 버전으로 점진적으로 이전하는 애플리케이션 릴리스 모델 [Blue-Green 배포란?](https://www.redhat.com/ko/topics/devops/what-is-blue-green-deployment)

![image](https://baek.dev/assets/images/post/2019/2019_013_004.jpg)

2. 카나리아 릴리즈
Canary Release는 새로운 버전의 소프트웨어를 운영 환경에 배포할 때, 전체 사용자들이 사용하도록 모든 인프라에 배포하기 전에 소규모의 사용자들에게만 먼저 배포함으로써 리스크를 줄이는 기법. [Canary Release, 네이버 블로그](https://m.blog.naver.com/muchine98/220262491992)

![image](https://martinfowler.com/bliki/images/canaryRelease/canary-release-2.png)

3. MTBF보다 MTTF?

- MTBF(Mean Time Between Failure) : 평균 무고장 시간
- MTTR(Mean Time To Repair) : 평균 수리 시간
- 때로는 자동화된 기능 테스트를 더 추가하는것보다 릴리즈를 보수하는데 같은 노력을 쏟는 것이 더 유익할 수 있다. 

## 교차기능 테스트

이 장의 대부분은 기능 테스트와 마이크로서비스 기반 시스템의 테스트가 어떻게 다른지 설명하는데 중점을 둔다. 논의가 필요한 다른 범주의 테스트도 있다.

- 비기능적 요구사항 : 일반적인 기능과 같이 단순히 구현될 수 없는 시스템의 특징을 기술하는데 사용(교차기능 요구사항), 속성 테스팅 분면에 속함. 실환경에서만 충족될 수 있다.

### 성능 테스트
마이크로서비스에서 성능 테스트가 더 중요해진 이유는 다른 마이크로서비스들과 네트워크를 넘은 호출때문이다. 이 때문에 성능 테스트는 모놀리틱 때보다 더 중요해졌다. 

그렇다면 성능 테스트는 어떻게 진행해야 하는가?
- 모의 고객 수를 점차 증가시키면서 성능 테스트 해보기
- 실환경과 가능한 한 일치시키기

성능 테스트는 소요 시간이 오래 걸리기 때문에, 주기적으로 진행하는 것이 좋다.  성능 테스트는 실제 시스템의 성능 모니터링을 지원받아 수행해야 한다. 
