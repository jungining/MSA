# 6. 배포
마이크로서비스를 세분화된 아키텍처에 배포할 때 도움이 될 수 있는 기법과 기술을 살펴보자.

## 6.1 지속적 통합이란
> continuous integration의 핵심 목표 : 모든 사람이 서로 동기를 맞추는 것

- 코드의 커밋 감지 -> 체크아웃 -> 코드의 컴퐈일/테스트 통과 확인
- CI 장점
  1. 코드 품질에 대해 빠른 피드백을 얻을 수 있다.
  2. 바이너리 산출물을 자동으로 생성할 수 있다.
  3. 버전관리된 코드와 산출물에 대해 어떤 테스트가 수행되었는지 확인할 수 있다.
- CI 도구의 사용과 CI의 실천을 혼동하지 말자.
- Jez Humble의 3가지 질문
  1. 하루에 한번 메인 브랜치에 체크인하는가?
  2. 변경을 확인할 테스트 집합이 있는가?
  3. 빌드가 깨졌을때 팀이 그것을 최우선으로 해결하는가?

## 6.2 지속적 통합을 마이크로서비스로 매핑하기
- CI빌드를 어떻게 개별 마이크로서비스와 매핑할것인지 생각해보자.
1. 가장 단순한 방법 : 모놀리식 빌드
  - 단점 : 어떤 변경에도 빌드가 시작한다. (cycle time에 영향을 준다.)
2. 변형 : 단일 소스 트리를 두고 다수의 CI빌드가 소스 트리의 부분들과 매핑되게 하는 것
  - 장점 : 체크인/체크아웃 과정이 더 단순해진다
  - 단점 : 한번에 여러 서비스의 소스 코드에 체크인하는 습관이 들기 쉽다.
3. BEST : 마이크로서비스당 하나의 CI빌드 두기
  - 변경이 발생하면 필요한 빌드와 테스트만 수행, 배포할 하나의 산출물만 얻는다.

## 6.3 빌드 파이프라인과 지속적 배포

- 빌드 파이프라인 : 빌드 내에 여러 단계를 두는것. 이 파이프라인을 통해 산출물이 생성되고 실환경까지 보내진다.
- 하나의 마이크로서비스당 하나의 파이프라인 권장(예외 : 초창기).
- 지속적 배포(continuous deployment) : 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고, 모든 체크인을 릴리즈 후보로 여기는 접근방법

## 6.4 플랫폼별 산출물

- 기술스택 별 산출물이 다 다르다. ex) ruby gem, java jar/war, python egg
- 산출물을 배포하고 실행하기 위해 다른 software를 설치하고 구성할 방법이 필요하다.
- 자동화된 관리 도구 예 : (Puppet)[https://puppet.com/] (ruby로 만들어진 시스템 관리 자동화 툴), (Chef)[https://www.chef.io/products/chef-automate] (인프라 자동화 도구)
- 자동화는 하부 산출물의 배포 매커니즘의 차이를 감추는 데 도움이 된다.


## 6.5 운영 체제 산출물
- 특정 기술에 제한적인 산출물과 관련된 문제를 해결할 수 있는 방법 : 하부 운영체제에 네이티브한 산출물 생성
- 장점 : 배포 관점에서 하부 기술에 신경쓰지 않아도 된다.
- 단점
  - 초기 패키지 구성시 어려움이 있을 수 있다.(윈도우 까다로움)
  - 다양한 운영 체제 산출물 관리시 부담

## 6.6 커스텀 이미지
- 자동화 구성 관리 시스템(퍼펫, 쉐프 등)의 challenge는 머신 상에서 스크립트의 실행 소요 시간
- spin-up time을 줄이기 위한 방법
  - 공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만든다.
    - 단점 1 : 이미지 생성 시간이 오래걸린다.
    - 단점 2 : 생성된 이미지가 크다.


## 6.7 환경
## 6.8 서비스 환경 구성
## 6.9 서비스와 호스트 매핑
## 6.10 자동화
## 6.11 물리 머신에서 가상화로
## 6.12 배포 인터페이스
## 6.13 마치며
