# 6. 배포
마이크로서비스를 세분화된 아키텍처에 배포할 때 도움이 될 수 있는 기법과 기술을 살펴보자.

## 6.1 지속적 통합이란
> continuous integration의 핵심 목표 : 모든 사람이 서로 동기를 맞추는 것

- 코드의 커밋 감지 -> 체크아웃 -> 코드의 컴일/테스트 통과 확인
- CI 장점
  1. 코드 품질에 대해 빠른 피드백을 얻을 수 있다.
  2. 바이너리 산출물을 자동으로 생성할 수 있다.
  3. 버전관리된 코드와 산출물에 대해 어떤 테스트가 수행되었는지 확인할 수 있다.
- CI 도구의 사용과 CI의 실천을 혼동하지 말자.
- Jez Humble의 3가지 질문
  1. 하루에 한번 메인 브랜치에 체크인하는가?
  2. 변경을 확인할 테스트 집합이 있는가?
  3. 빌드가 깨졌을때 팀이 그것을 최우선으로 해결하는가?

## 6.2 지속적 통합을 마이크로서비스로 매핑하기
- CI빌드를 어떻게 개별 마이크로서비스와 매핑할것인지 생각해보자.
1. 가장 단순한 방법 : 모놀리식 빌드
  - 단점 : 어떤 변경에도 빌드가 시작한다. (cycle time에 영향을 준다.)
2. 변형 : 단일 소스 트리를 두고 다수의 CI빌드가 소스 트리의 부분들과 매핑되게 하는 것
  - 장점 : 체크인/체크아웃 과정이 더 단순해진다
  - 단점 : 한번에 여러 서비스의 소스 코드에 체크인하는 습관이 들기 쉽다.
3. BEST : 마이크로서비스당 하나의 CI빌드 두기
  - 변경이 발생하면 필요한 빌드와 테스트만 수행, 배포할 하나의 산출물만 얻는다.

## 6.3 빌드 파이프라인과 지속적 배포

- 빌드 파이프라인 : 빌드 내에 여러 단계를 두는것. 이 파이프라인을 통해 산출물이 생성되고 실환경까지 보내진다.
- 하나의 마이크로서비스당 하나의 파이프라인 권장(예외 : 초창기).
- 지속적 배포(continuous deployment) : 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고, 모든 체크인을 릴리즈 후보로 여기는 접근방법

## 6.4 플랫폼별 산출물

- 기술스택 별 산출물이 다 다르다. ex) ruby gem, java jar/war, python egg
- 산출물을 배포하고 실행하기 위해 다른 software를 설치하고 구성할 방법이 필요하다.
- 자동화된 관리 도구 예 : [Puppet](https://puppet.com/) (ruby로 만들어진 시스템 관리 자동화 툴), [Chef](https://www.chef.io/products/chef-automate) (인프라 자동화 도구)
- 자동화는 하부 산출물의 배포 매커니즘의 차이를 감추는 데 도움이 된다.


## 6.5 운영 체제 산출물
- 특정 기술에 제한적인 산출물과 관련된 문제를 해결할 수 있는 방법 : 하부 운영체제에 네이티브한 산출물 생성
- 장점 : 배포 관점에서 하부 기술에 신경쓰지 않아도 된다.
- 단점
  - 초기 패키지 구성시 어려움이 있을 수 있다.(윈도우 까다로움)
  - 다양한 운영 체제 산출물 관리시 부담

## 6.6 커스텀 이미지
- 자동화 구성 관리 시스템(퍼펫, 쉐프 등)의 challenge는 머신 상에서 스크립트의 실행 소요 시간
- spin-up time을 줄이기 위한 방법
  - 공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만든다.
    - 단점 1 : 이미지 생성 시간이 오래걸린다.
    - 단점 2 : 생성된 이미지가 크다.
  - 서비스를 이미지 안에 구워내고 서비스 산출물이 이미지가 된다.
    - 빠른 spin-up time
    - 기술 스택들의 차이 추상화 가능
- 불변 서버
  - [불변 인프라 (Immutable Infrastructure)](https://zetawiki.com/wiki/%EB%B6%88%EB%B3%80_%EC%9D%B8%ED%94%84%EB%9D%BC)
  - 변경 발생시 서버를 완전히 새로 구성하여 배포하고 기존 서버는 폐기한다.


## 6.7 환경

- 소프트웨어가 CD파이프라인 단계를 거치면서 다양한 종류의 환경에 배포된다.
- 우리가 배포하고자 하는 서비스는 모든 다양한 환경에서 동일해야 한다. 
- 배포 플랫폼들은 마이크로서비스의 여러 환경을 관리할 수 있게 해준다.

## 6.8 서비스 환경 구성

- 서비스는 몇 가지 환경 구성(configuration)을 필요로 한다.
- 환경마다 바뀌는 configuration을 어떻게 다뤄야 할까? 
    - 환경당 하나의 산출물을 빌드하고 환경 구성을 그 산출물에 포함
        - 실환경에서 검증되었는지 확인 불가
        - 산출물들을 빌드하기위해서는 추가적인 시간 소요
        - 민감한 configuration 데이터를 다루는 문제
    - 단일 산출물을 생성하여 환경 구성을 분리해서 관리
        - properties file / 설치 프로세스에 전달될 매개 변수
        - 환경 구성을 제공하는 전용 시스템 사용 (11장에서 계속)

## 6.9 서비스와 호스트 매핑

- 머신 X 박스 X 호스트 O
    - ex ) EC2 인스턴스

호스트 당 얼마나 많은 서비스를 넣어야 하나?

1. 호스트당 다수 서비스
    - 장 : 단순, 비용 적음
    - 단1 : 모니터링이 어렵다(CPU 상태 추적)
    - 단2 : 다른곳에 문제를 일으키지 않는 배포르 보장해야 한다.
    - 단3 : 배포 산출물의 방식 제한
2. 애플리케이션 컨테이너
    - 장 : 언어 런타임의 overhead를 줄일 수 있다. ex) JVM
    - 단1 : 기술의 선택을 제약
    - 단2 : 사용하는 리소스와 스레드 분석 복잡
3. 호스트당 단일 서비스
    - 장1 : 한 호스트의 고장은 한 서비스에만 영향을 미친다.
    - 장2 : 특정 서비스를 다른 서비스와 독립적으로 확장
    - 단 : 증가된 호스트 숫자 / 비용
4. PaaS(Platform as a Service)
- ex) Heroku : 서비스의 실행 처리, DB같은 서비스도 지원
- ![image](https://user-images.githubusercontent.com/11023497/121039110-c6b62580-c7eb-11eb-8158-eabdf4bc38cd.png)


## 6.10 자동화

- 호스트의 통제와 서비스의 배포를 자동화한다면 개발자가 생산성을 유지할 수 있게 해준다.
- 자동화는 필수다.

## 6.11 물리 머신에서 가상화로

1. 전통적 가상화 (VM ware, AWS)
    - 호스트당 하나의 서비스 하기 어려움.. 비용문제
    - 하이퍼바이저의 오버헤드로 더 많은 리소스가 사용된다.
2. [Vagrant(베이그랜트)](https://www.vagrantup.com/)
    - 배포 플랫폼. 실환경보다는 개발/테스트용으로 사용
    - 로컬 머신 상에 실환경과 유사한 환경을 쉽게 생성하도록 도와줌
3. 리눅스 컨테이너
    - 다른 프로세스드를 위해 분리된 공간 생성
    - 장 : 자원 절약 / 가상화머신보다 프로비저닝 빠름
    - 단 : 외부에서 볼 때 외부를 하부의 컨테이너로 라우팅할 방법이 필요함.
4. Docker
    - 경량 컨테이너 상에 구축된 플랫폼
    - 애플리케이션(vm에서의 이미지와 같은 개념)을 생성하고 배포 가능
    - 컨테이너 프로비저닝 관리
    - 네트워킹 문제 처리
    - 자체 레지스트리 제공
    - IaaS CaaS Paas
    - 
    ![image](https://user-images.githubusercontent.com/11023497/121037862-c79a8780-c7ea-11eb-83c1-b6b923d227f6.png)


## 6.13 마치며

1. 한 서비스를 다른 서비스와 독립적으로 릴리즈할수 있는 능력을 유지하는데 집중하라. 
- 마이크로서비스 당 하나의 CI빌드

2. 호스트 및 컨테이너당 단일 서비스
- 변경되는 부분을 더 쉽고 저비용으로 관리하기 위해 LXC또는 도커와 같은 대체 기술을 살펴보라.

3. 모든 것을 자동화하라

